# -*- coding: utf-8 -*-
"""Email Tracker.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gVS83mjKcdLR15m9jdXFY-MTzT3B1nYJ
"""

!pip install dnspython validate_email_address tqdm

# Install dependencies
    !pip install dnspython validate_email_address tqdm
# Advanced Email Validation with DNS, SMTP, and Intelligent Classification (Streamlit Version)
%%writefile app.py
import streamlit as st
import pandas as pd
import smtplib
import dns.resolver
import socket
import re
from datetime import datetime
from io import StringIO
import ast

# Helper functions
def get_mx_record(domain):
    try:
        records = dns.resolver.resolve(domain, 'MX')
        return sorted([(r.preference, str(r.exchange)) for r in records])[0][1]
    except Exception:
        return None

def smtp_check(email, mx_host):
    try:
        server = smtplib.SMTP(timeout=10)
        server.connect(mx_host)
        server.helo(socket.gethostname())
        server.mail('verify@example.com')
        code, message = server.rcpt(email)
        server.quit()
        return code, message.decode()
    except Exception as e:
        return None, str(e)

def suggest_typo(domain):
    common_domains = ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com',
                      'icloud.com', 'aol.com', 'protonmail.com', 'zoho.com']
    suggestions = {}
    for common in common_domains:
        dist = sum(1 for a, b in zip(domain, common) if a != b) + abs(len(domain) - len(common))
        if dist <= 2:
            suggestions[common] = dist
    return sorted(suggestions, key=suggestions.get)[:1] if suggestions else []

def classify(email):
    result = {
        "email": email,
        "status": "Unknown",
        "reason": "",
        "suggested_fix": ""
    }

    if not re.match(r"[^@]+@[^@]+\.[^@]+", email):
        result["status"] = "Invalid"
        result["reason"] = "Invalid format or typo"
        return result

    local, domain = email.split('@')

    mx_host = get_mx_record(domain)
    if not mx_host:
        result["status"] = "Failed"
        result["reason"] = "DNS or MX record missing"
        result["suggested_fix"] = ', '.join(suggest_typo(domain))
        return result

    code, message = smtp_check(email, mx_host)
    if code is None:
        result["status"] = "Error"
        result["reason"] = f"SMTP error: {message}"
    elif code == 250:
        result["status"] = "Valid"
        result["reason"] = "Accepted by server"
    elif code == 550:
        result["status"] = "Invalid"
        result["reason"] = "Nonexistent address or deleted mailbox"
        result["suggested_fix"] = ', '.join(suggest_typo(domain))
    elif code == 450:
        result["status"] = "Temporary Fail"
        result["reason"] = "Temporary server issue (greylisting, retry later)"
    else:
        result["status"] = "Unknown"
        result["reason"] = f"SMTP response: {code} - {message}"
    return result

# Streamlit App
st.set_page_config(page_title="Advanced Email Validator", layout="wide")
st.title("📧 Advanced Email Validator with SMTP & DNS Checks")

uploaded_file = st.file_uploader("Upload a CSV file with an 'email' column", type="csv")
if uploaded_file is not None:
    try:
        df = pd.read_csv(uploaded_file)
        if 'email' not in df.columns:
            st.error("CSV must contain a column named 'email'")
        else:
            emails = df['email'].dropna().unique()

            st.info(f"Running validation on {len(emails)} unique email(s)...")
            results = []
            progress = st.progress(0)
            for idx, email in enumerate(emails):
                results.append(classify(email))
                progress.progress((idx + 1) / len(emails))

            result_df = pd.DataFrame(results)
            st.success("✅ Validation complete!")

            st.subheader("📋 Full Results")
            st.dataframe(result_df)

            # Timestamp
            run_timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')

            # Download full results
            csv_full = result_df.to_csv(index=False).encode('utf-8')
            st.download_button(
                label="⬇️ Download Full Result CSV",
                data=csv_full,
                file_name=f"email_validation_results_{run_timestamp}.csv",
                mime='text/csv'
            )

            # Filter valid emails
            valid_df = result_df[result_df['status'] == 'Valid']
            csv_valid = valid_df.to_csv(index=False).encode('utf-8')
            st.download_button(
                label="⬇️ Download Valid Emails Only CSV",
                data=csv_valid,
                file_name=f"valid_emails_only_{run_timestamp}.csv",
                mime='text/csv'
            )
    except Exception as e:
        st.error(f"❌ Error processing file: {e}")


import pandas as pd
import smtplib
import dns.resolver
from validate_email_address import validate_email
import socket
import re
from tqdm import tqdm
from IPython.display import display
from google.colab import files

# Upload CSV
uploaded = files.upload()
filename = list(uploaded.keys())[0]

# Read email list
df = pd.read_csv(filename)
if 'email' not in df.columns:
    raise ValueError("CSV must contain a column named 'email'")
emails = df['email'].dropna().unique()

# Helper functions
def get_mx_record(domain):
    try:
        records = dns.resolver.resolve(domain, 'MX')
        return sorted([(r.preference, str(r.exchange)) for r in records])[0][1]
    except Exception as e:
        return None

def smtp_check(email, mx_host):
    try:
        server = smtplib.SMTP(timeout=10)
        server.connect(mx_host)
        server.helo(socket.gethostname())
        server.mail('verify@example.com')
        code, message = server.rcpt(email)
        server.quit()
        return code, message.decode()
    except Exception as e:
        return None, str(e)

def classify(email):
    result = {
        "email": email,
        "status": "Unknown",
        "reason": ""
    }

    # Basic syntax check
    if not re.match(r"[^@]+@[^@]+\.[^@]+", email):
        result["status"] = "Invalid"
        result["reason"] = "Invalid format or typo"
        return result

    domain = email.split('@')[-1]

    # DNS / MX Check
    mx_host = get_mx_record(domain)
    if not mx_host:
        result["status"] = "Failed"
        result["reason"] = "DNS or MX record missing"
        return result

    # SMTP check
    code, message = smtp_check(email, mx_host)
    if code is None:
        result["status"] = "Error"
        result["reason"] = f"SMTP error: {message}"
    elif code == 250:
        result["status"] = "Valid"
        result["reason"] = "Accepted by server"
    elif code == 550:
        result["status"] = "Invalid"
        result["reason"] = "Nonexistent address or deleted mailbox"
    elif code == 450:
        result["status"] = "Temporary Fail"
        result["reason"] = "Temporary server issue (greylisting, retry later)"
    else:
        result["status"] = "Unknown"
        result["reason"] = f"SMTP response: {code} - {message}"

    return result

# Run validation
results = []
for email in tqdm(emails, desc="Checking emails"):
    results.append(classify(email))

result_df = pd.DataFrame(results)
display(result_df)

# Export result
output_file = 'email_validation_results.csv'
result_df.to_csv(output_file, index=False)
files.download(output_file)

!pip install pandas dnspython validate_email_address tqdm python-whois

# Advanced Email Validation with DNS, SMTP, and Intelligent Classification
# Install dependencies
!pip install dnspython validate_email_address tqdm

import pandas as pd
import smtplib
import dns.resolver
from validate_email_address import validate_email
import socket
import re
from tqdm import tqdm
from IPython.display import display
from google.colab import files
from datetime import datetime

# Timestamp for file naming
run_timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')

# Upload CSV
uploaded = files.upload()
filename = list(uploaded.keys())[0]

# Read email list
df = pd.read_csv(filename)
if 'email' not in df.columns:
    raise ValueError("CSV must contain a column named 'email'")
emails = df['email'].dropna().unique()

# Helper functions
def get_mx_record(domain):
    try:
        records = dns.resolver.resolve(domain, 'MX')
        return sorted([(r.preference, str(r.exchange)) for r in records])[0][1]
    except Exception:
        return None

def smtp_check(email, mx_host):
    try:
        server = smtplib.SMTP(timeout=10)
        server.connect(mx_host)
        server.helo(socket.gethostname())
        server.mail('verify@example.com')
        code, message = server.rcpt(email)
        server.quit()
        return code, message.decode()
    except Exception as e:
        return None, str(e)

def suggest_typo(domain):
    common_domains = ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com',
                      'icloud.com', 'aol.com', 'protonmail.com', 'zoho.com']
    suggestions = {}
    for common in common_domains:
        dist = sum(1 for a, b in zip(domain, common) if a != b) + abs(len(domain) - len(common))
        if dist <= 2:
            suggestions[common] = dist
    return sorted(suggestions, key=suggestions.get)[:1] if suggestions else []

def classify(email):
    result = {
        "email": email,
        "status": "Unknown",
        "reason": "",
        "suggested_fix": ""
    }

    # Basic syntax check
    if not re.match(r"[^@]+@[^@]+\.[^@]+", email):
        result["status"] = "Invalid"
        result["reason"] = "Invalid format or typo"
        return result

    local, domain = email.split('@')

    # DNS / MX Check
    mx_host = get_mx_record(domain)
    if not mx_host:
        result["status"] = "Failed"
        result["reason"] = "DNS or MX record missing"
        result["suggested_fix"] = suggest_typo(domain)
        return result

    # SMTP check
    code, message = smtp_check(email, mx_host)
    if code is None:
        result["status"] = "Error"
        result["reason"] = f"SMTP error: {message}"
    elif code == 250:
        result["status"] = "Valid"
        result["reason"] = "Accepted by server"
    elif code == 550:
        result["status"] = "Invalid"
        result["reason"] = "Nonexistent address or deleted mailbox"
        result["suggested_fix"] = suggest_typo(domain)
    elif code == 450:
        result["status"] = "Temporary Fail"
        result["reason"] = "Temporary server issue (greylisting, retry later)"
    else:
        result["status"] = "Unknown"
        result["reason"] = f"SMTP response: {code} - {message}"
    return result

# Run validation
results = []
for email in tqdm(emails, desc="Checking emails"):
    results.append(classify(email))

result_df = pd.DataFrame(results)
display(result_df)

# Export full result
output_file = f'email_validation_results_{run_timestamp}.csv'
result_df.to_csv(output_file, index=False)
files.download(output_file)

# Export only valid emails
valid_emails_df = result_df[result_df['status'] == 'Valid']
valid_output_file = f'valid_emails_only_{run_timestamp}.csv'
valid_emails_df.to_csv(valid_output_file, index=False)
files.download(valid_output_file)

!pip install streamlit dnspython validate_email_address tqdm

# Commented out IPython magic to ensure Python compatibility.
# # Advanced Email Validation with DNS, SMTP, and Intelligent Classification (Streamlit Version)
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import smtplib
# import dns.resolver
# import socket
# import re
# from datetime import datetime
# from io import StringIO
# import ast
# 
# # Helper functions
# def get_mx_record(domain):
#     try:
#         records = dns.resolver.resolve(domain, 'MX')
#         return sorted([(r.preference, str(r.exchange)) for r in records])[0][1]
#     except Exception:
#         return None
# 
# def smtp_check(email, mx_host):
#     try:
#         server = smtplib.SMTP(timeout=10)
#         server.connect(mx_host)
#         server.helo(socket.gethostname())
#         server.mail('verify@example.com')
#         code, message = server.rcpt(email)
#         server.quit()
#         return code, message.decode()
#     except Exception as e:
#         return None, str(e)
# 
# def suggest_typo(domain):
#     common_domains = ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com',
#                       'icloud.com', 'aol.com', 'protonmail.com', 'zoho.com']
#     suggestions = {}
#     for common in common_domains:
#         dist = sum(1 for a, b in zip(domain, common) if a != b) + abs(len(domain) - len(common))
#         if dist <= 2:
#             suggestions[common] = dist
#     return sorted(suggestions, key=suggestions.get)[:1] if suggestions else []
# 
# def classify(email):
#     result = {
#         "email": email,
#         "status": "Unknown",
#         "reason": "",
#         "suggested_fix": ""
#     }
# 
#     if not re.match(r"[^@]+@[^@]+\.[^@]+", email):
#         result["status"] = "Invalid"
#         result["reason"] = "Invalid format or typo"
#         return result
# 
#     local, domain = email.split('@')
# 
#     mx_host = get_mx_record(domain)
#     if not mx_host:
#         result["status"] = "Failed"
#         result["reason"] = "DNS or MX record missing"
#         result["suggested_fix"] = ', '.join(suggest_typo(domain))
#         return result
# 
#     code, message = smtp_check(email, mx_host)
#     if code is None:
#         result["status"] = "Error"
#         result["reason"] = f"SMTP error: {message}"
#     elif code == 250:
#         result["status"] = "Valid"
#         result["reason"] = "Accepted by server"
#     elif code == 550:
#         result["status"] = "Invalid"
#         result["reason"] = "Nonexistent address or deleted mailbox"
#         result["suggested_fix"] = ', '.join(suggest_typo(domain))
#     elif code == 450:
#         result["status"] = "Temporary Fail"
#         result["reason"] = "Temporary server issue (greylisting, retry later)"
#     else:
#         result["status"] = "Unknown"
#         result["reason"] = f"SMTP response: {code} - {message}"
#     return result
# 
# # Streamlit App
# st.set_page_config(page_title="Advanced Email Validator", layout="wide")
# st.title("📧 Advanced Email Validator with SMTP & DNS Checks")
# 
# uploaded_file = st.file_uploader("Upload a CSV file with an 'email' column", type="csv")
# if uploaded_file is not None:
#     try:
#         df = pd.read_csv(uploaded_file)
#         if 'email' not in df.columns:
#             st.error("CSV must contain a column named 'email'")
#         else:
#             emails = df['email'].dropna().unique()
# 
#             st.info(f"Running validation on {len(emails)} unique email(s)...")
#             results = []
#             progress = st.progress(0)
#             for idx, email in enumerate(emails):
#                 results.append(classify(email))
#                 progress.progress((idx + 1) / len(emails))
# 
#             result_df = pd.DataFrame(results)
#             st.success("✅ Validation complete!")
# 
#             st.subheader("📋 Full Results")
#             st.dataframe(result_df)
# 
#             # Timestamp
#             run_timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
# 
#             # Download full results
#             csv_full = result_df.to_csv(index=False).encode('utf-8')
#             st.download_button(
#                 label="⬇️ Download Full Result CSV",
#                 data=csv_full,
#                 file_name=f"email_validation_results_{run_timestamp}.csv",
#                 mime='text/csv'
#             )
# 
#             # Filter valid emails
#             valid_df = result_df[result_df['status'] == 'Valid']
#             csv_valid = valid_df.to_csv(index=False).encode('utf-8')
#             st.download_button(
#                 label="⬇️ Download Valid Emails Only CSV",
#                 data=csv_valid,
#                 file_name=f"valid_emails_only_{run_timestamp}.csv",
#                 mime='text/csv'
#             )
#     except Exception as e:
#         st.error(f"❌ Error processing file: {e}")
#

!npm install -g localtunnel

!curl ipv4.icanhazip.com/

!streamlit run app.py &>/content/logs.txt &

!streamlit run app.py & npx localtunnel --port 8501
